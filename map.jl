using XML
using GeometryBasics
using LinearAlgebra

struct Room{T}
    # Room dimensions 100 x 100 as example
    # We assume that there's a wall around this
    dims :: Tuple{T, T}
    # Internal walls
    walls :: Vector{Line{2, T}}

    transmitters :: Vector{Point{2, T}}
    
    function Room(
            x::T, 
            y::T, 
            walls::Vector{Line{2, T}},
            transmitters::Vector{Point{2, T}}
    ) where T
        for w ∈ walls
            p, q = w
            @assert(0 ≤ p[1] ≤ x && 0 ≤ p[2] ≤ y)
            @assert(0 ≤ q[1] ≤ x && 0 ≤ q[2] ≤ y)
        end

        for t ∈ transmitters
            @assert(0 ≤ t[1] ≤ x && 0 ≤ t[2] ≤ y)
        end
        
        new{T}((x, y), walls, transmitters)
    end
end

### GENERATED BY GEMINI
### THESE ARE THE ONLY PARTS OF THIS PROJECT WITH AI AID BECAUSE
### I AM A BIT LAZY TO DO THE BORING PARSING PART.
function parse_node_to_lines(node::XML.Node)
    if !haskey(node.attributes, "d")
        return Line{2, Float32}[]
    end
    
    d_str = node.attributes["d"]
    
    # 1. Replace commas with spaces so parse() doesn't fail
    d_clean = replace(d_str, "," => " ")
    
    # 2. Add spaces around commands to separate them from numbers
    d_spaced = replace(d_clean, r"([a-zA-Z])" => s" \1 ")
    
    # 3. Tokenize
    tokens = split(d_spaced)
    
    lines = Line{2, Float32}[]
    curr = [0f0, 0f0]
    start_point = [0f0, 0f0]
    i = 1
    
    while i <= length(tokens)
        cmd = tokens[i]
        
        # Check if the token is a command or a number
        # If it's a number, the previous command repeats (common in SVG)
        if match(r"^[a-zA-Z]$", cmd) === nothing
            # This handles implicit "l" or "L" after an initial "m" or "M"
            # However, for simplicity in your assignment, we'll assume commands are explicit
            i += 1
            continue
        end

        if cmd == "m" || cmd == "M"
            x, y = parse(Float32, tokens[i+1]), parse(Float32, tokens[i+2])
            if cmd == "m"
                curr .+= [x, y]
            else
                curr .= [x, y]
            end
            start_point .= curr
            i += 3
        elseif cmd == "l" || cmd == "L"
            x, y = parse(Float32, tokens[i+1]), parse(Float32, tokens[i+2])
            next_p = cmd == "l" ? curr .+ [x, y] : [x, y]
            push!(lines, Line(Point{2, Float32}(curr...), Point{2, Float32}(next_p...)))
            curr .= next_p
            i += 3
        elseif cmd == "h" || cmd == "H"
            val = parse(Float32, tokens[i+1])
            next_p = [cmd == "h" ? curr[1] + val : val, curr[2]]
            push!(lines, Line(Point{2, Float32}(curr...), Point{2, Float32}(next_p...)))
            curr .= next_p
            i += 2
        elseif cmd == "v" || cmd == "V"
            val = parse(Float32, tokens[i+1])
            next_p = [curr[1], cmd == "v" ? curr[2] + val : val]
            push!(lines, Line(Point{2, Float32}(curr...), Point{2, Float32}(next_p...)))
            curr .= next_p
            i += 2
        elseif cmd == "z" || cmd == "Z"
            if curr != start_point
                push!(lines, Line(Point{2, Float32}(curr...), Point{2, Float32}(start_point...)))
            end
            curr .= start_point
            i += 1
        else
            i += 1 
        end
    end
    return lines
end

function loadroom(svgfile; transmitters = Point{2, Float32}[])
    xmldoc = read(svgfile, Node)
    svg_root = xmldoc[end] 
    
    # Intended pixel dimensions
    target_w = parse(Float32, svg_root.attributes["width"])
    target_h = parse(Float32, svg_root.attributes["height"])

    # ViewBox dimensions (the actual coordinate range used in the 'd' paths)
    vb = split(svg_root.attributes["viewBox"])
    vb_w = parse(Float32, vb[3])
    vb_h = parse(Float32, vb[4])

    scale_x = target_w / vb_w
    scale_y = target_h / vb_h

    all_walls = Line{2, Float32}[]
    layer = findfirst(n -> n.tag == "g", children(svg_root))
    
    for node in children(svg_root[layer])
        if node.tag == "path"
            raw_lines = parse_node_to_lines(node)
            # Apply scaling to each point in the line
            for line in raw_lines
                p1_scaled = Point{2, Float32}(line[1][1] * scale_x, line[1][2] * scale_y)
                p2_scaled = Point{2, Float32}(line[2][1] * scale_x, line[2][2] * scale_y)
                push!(all_walls, Line(p1_scaled, p2_scaled))
            end
        end
    end

    Room(target_w, target_h, all_walls, transmitters)
end
# END GENERATED BY GEMINI

function plotroom(r::Room; bg::Union{Matrix{Float32}, Nothing} = nothing, title="")
    xticks = 0:20:r.dims[1]
    yticks = 0:20:r.dims[2]
    p = plot(
        aspect_ratio=:equal, 
        legend=false, 
        grid=true,
        axis=false,
        ticks=false,
        title=title
    )

    w, h = r.dims
    
    if !isnothing(bg)
        # heatmap expects [rows, cols]
        hmap_data = permutedims(bg, (2, 1))
        xs = range(0, w, length=size(bg, 1))
        ys = range(0, h, length=size(bg, 2))

        heatmap!(p, xs, ys, hmap_data, c=:viridis)
    end

    
    boundary_x = [0, w, w, 0, 0]
    boundary_y = [0, 0, h, h, 0]
    plot!(p, boundary_x, boundary_y, 
        color=:black, linestyle=:dash, linewidth=2)

    for w ∈ r.walls
        p1, p2 = w

        xs = [p1[1], p2[1]]
        ys = [p1[2], p2[2]]
        
        plot!(p, xs, ys, color=:cyan, linewidth=3)
    end

    if !isempty(r.transmitters)
        tx_x = [t[1] for t in r.transmitters]
        tx_y = [t[2] for t in r.transmitters]
        
        scatter!(p, tx_x, tx_y, 
            markersize=8, 
            color=:blue, 
            markerstrokecolor=:black,
            label="Tx"
        )
    end

    p
end

function plot_discrete_heatmap(r::Room, fmap::Matrix{Float32}; title = "Signal Coverage")
    plotroom(r; bg=fmap, title=title)
end

function rasterize(r::Room, grid_size::Tuple{Int, Int}=(256, 256))
    w_grid, h_grid = grid_size

    wall_map = zeros(Float32, w_grid, h_grid)

    scale_x = w_grid / r.dims[1]
    scale_y = h_grid / r.dims[2]

    # CHANNEL 1: WALL MARKERS
    # Mark the pixels that are walls with 1.
    for wall in r.walls
        p1, p2 = wall

        # Determine the number of steps for drawing based on line length so we ensure 
        # that there are no gaps in the line segment. Otherwise, 
        # signal may leak ;)
        dist = norm(p2 - p1)
        steps = Int(ceil(dist * max(scale_x, scale_y) * 2))
        
        for i in 0:steps
            t = i / steps
            p = p1 + t * (p2 - p1)
            
            # coords to grid idx
            idx_x = Int(clamp(floor(p[1] * scale_x) + 1, 1, w_grid))
            idx_y = Int(clamp(floor(p[2] * scale_y) + 1, 1, h_grid))
            
            # 1 means wall.
            wall_map[idx_x, idx_y] = 1.0 
        end
    end

    # CHANNEL 2: TX MARKERS. Paper COST CA20120 stores the TX marker not explicitly but by
    # distance to the nearest transmitter.
    tx_map = fill(Inf32, w_grid, h_grid)
    
    for tx in r.transmitters
        for x in 1:w_grid
            for y in 1:h_grid
                # Location of the tx pixel.
                px = (x - 0.5) / scale_x
                py = (y - 0.5) / scale_y
                pixel_point = Point2f(px, py)

                # Find distance to nearest transmitter in coordinate units (pixels)
                min_d_pixels = Inf32
                for tx in r.transmitters
                    d_pix = norm(pixel_point - tx)
                    min_d_pixels = min(min_d_pixels, d_pix)
                end

                d_meters = min_d_pixels / PIXELS_PER_METER
                tx_map[x, y] = d_meters
            end
        end
    end

    return cat(wall_map, tx_map, dims=3)
end

function generate_random_room(; dim=256f0, num_walls=10, num_tx=3)
    # Create random walls
    walls = Line{2, Float32}[
        Line(
            Point2f(rand() * dim, rand() * dim),
            Point2f(rand() * dim, rand() * dim)
        )
        for _ in 1:num_walls
    ]

    # Random transmitters
    txs = [Point2f(rand() * dim, rand() * dim) for _ in 1:num_tx]

    # txs[1] is the left-most tx.
    sort!(txs, by = p -> p[1])
    return Room(dim, dim, walls, txs)
end