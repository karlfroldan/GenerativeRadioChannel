using XML
using GeometryBasics
using LinearAlgebra

struct Room{T}
    # Room dimensions 100 x 100 as example
    # We assume that there's a wall around this
    dims :: Tuple{T, T}
    # Internal walls
    walls :: Vector{Line{2, T}}

    transmitters :: Vector{Point{2, T}}
    
    function Room(
            x::T, 
            y::T, 
            walls::Vector{Line{2, T}},
            transmitters::Vector{Point{2, T}}
    ) where T
        for w ∈ walls
            p, q = w
            @assert(0 ≤ p[1] ≤ x && 0 ≤ p[2] ≤ y)
            @assert(0 ≤ q[1] ≤ x && 0 ≤ q[2] ≤ y)
        end

        for t ∈ transmitters
            @assert(0 ≤ t[1] ≤ x && 0 ≤ t[2] ≤ y)
        end
        
        new{T}((x, y), walls, transmitters)
    end
end

### GENERATED BY GEMINI
### THESE ARE THE ONLY PARTS OF THIS PROJECT WITH AI AID BECAUSE
### I AM A BIT LAZY TO DO THE BORING PARSING PART.
function parse_node_to_line(node::XML.Node)
    # 1. Extract the "d" attribute
    # In XML.jl, attributes are typically stored in the `.attributes` dict
    if !haskey(node.attributes, "d")
        error("Node does not have a 'd' attribute")
    end
    d_str = node.attributes["d"]

    # 2. Extract numbers using Regex
    # Matches integers, floats, and scientific notation, ignoring 'M', 'L', spaces, commas
    float_pattern = r"[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?"
    matches = collect(eachmatch(float_pattern, d_str))

    # 3. Validation
    if length(matches) < 4
        error("Path string '$d_str' does not contain enough coordinates for a Line.")
    end

    # 4. Parse first 4 matches into Float32
    coords = parse.(Float32, [m.match for m in matches[1:4]])

    # 5. Construct Points and Line
    p1 = Point{2, Float32}(coords[1], coords[2])
    p2 = Point{2, Float32}(coords[3], coords[4])

    return Line(p1, p2)
end
# END GENERATED BY GEMINI

function loadroom(svgfile; transmitters = Point{2, Float32}[])
    xmldoc = read(svgfile, Node)
    parsenum(s) = parse(Float32, filter(isdigit, s))

    xdim = parsenum(xmldoc[end]["width"])
    ydim = parsenum(xmldoc[end]["height"])
    svgdoc = xmldoc[end][end]
    walls = [parse_node_to_line(n) for n ∈ children(svgdoc)]

    Room(xdim, ydim, walls, transmitters)
end

function plotroom(r::Room; bg::Union{Matrix{Float32}, Nothing} = nothing, title="")
    xticks = 0:20:r.dims[1]
    yticks = 0:20:r.dims[2]
    p = plot(
        aspect_ratio=:equal, 
        legend=false, 
        grid=true,
        axis=false,
        ticks=false,
        title=title
    )

    w, h = r.dims
    
    if !isnothing(bg)
        # heatmap expects [rows, cols]
        hmap_data = permutedims(bg, (2, 1))
        xs = range(0, w, length=size(bg, 1))
        ys = range(0, h, length=size(bg, 2))

        heatmap!(p, xs, ys, hmap_data, c=:viridis)
    end

    
    boundary_x = [0, w, w, 0, 0]
    boundary_y = [0, 0, h, h, 0]
    plot!(p, boundary_x, boundary_y, 
        color=:black, linestyle=:dash, linewidth=2)

    for w ∈ r.walls
        p1, p2 = w

        xs = [p1[1], p2[1]]
        ys = [p1[2], p2[2]]
        
        plot!(p, xs, ys, color=:cyan, linewidth=3)
    end

    if !isempty(r.transmitters)
        tx_x = [t[1] for t in r.transmitters]
        tx_y = [t[2] for t in r.transmitters]
        
        scatter!(p, tx_x, tx_y, 
            markersize=8, 
            color=:blue, 
            markerstrokecolor=:black,
            label="Tx"
        )
    end

    p
end

function plot_discrete_heatmap(r::Room, fmap::Matrix{Float32}; title = "Signal Coverage")
    plotroom(r; bg=fmap, title=title)
end

function rasterize(r::Room, grid_size::Tuple{Int, Int}=(100, 100))
    w_grid, h_grid = grid_size

    wall_map = zeros(Float32, w_grid, h_grid)

    scale_x = w_grid / r.dims[1]
    scale_y = h_grid / r.dims[2]

    # CHANNEL 1: WALL MARKERS
    # Mark the pixels that are walls with 1.
    for wall in r.walls
        p1, p2 = wall

        # Determine the number of steps for drawing based on line length so we ensure 
        # that there are no gaps in the line segment. Otherwise, 
        # signal may leak ;)
        dist = norm(p2 - p1)
        steps = Int(ceil(dist * max(scale_x, scale_y) * 2))
        
        for i in 0:steps
            t = i / steps
            p = p1 + t * (p2 - p1)
            
            # coords to grid idx
            idx_x = Int(clamp(floor(p[1] * scale_x) + 1, 1, w_grid))
            idx_y = Int(clamp(floor(p[2] * scale_y) + 1, 1, h_grid))
            
            # 1 means wall.
            wall_map[idx_x, idx_y] = 1.0 
        end
    end

    # CHANNEL 2: TX MARKERS. Paper COST CA20120 stores the TX marker not explicitly but by
    # distance to the nearest transmitter.
    tx_map = fill(Inf32, w_grid, h_grid)
    
    for tx in r.transmitters
        for x in 1:w_grid
            for y in 1:h_grid
                # Location of the tx pixel.
                px = (x - 0.5) / scale_x
                py = (y - 0.5) / scale_y
                pixel_point = Point2f(px, py)

                d = norm(pixel_point - tx)
                
                # Store minimum distance if multiple Txs exist
                tx_map[x, y] = min(tx_map[x, y], d)
            end
        end
    end

    return cat(wall_map, tx_map, dims=3)
end

function generate_random_room(; dim=100f0, num_walls=10, num_tx=3)
    # Create random walls
    walls = Line{2, Float32}[
        Line(
            Point2f(rand() * dim, rand() * dim),
            Point2f(rand() * dim, rand() * dim)
        )
        for _ in 1:num_walls
    ]

    # Random transmitters
    txs = [Point2f(rand() * dim, rand() * dim) for _ in 1:num_tx]
    return Room(dim, dim, walls, txs)
end